<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mueble 3D (compatibilidad amplia)</title>
<style>
  html,body { margin:0; height:100%; background:#0b0f14; color:#cde; font:14px system-ui; }
  #c { display:block; width:100%; height:100%; }
  .hud { position:fixed; left:10px; top:10px; z-index:10; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hud">Arrastrá para rotar · rueda/gesto para zoom</div>

<!-- CARGA UMD (no módulos) -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
(function(){
  // Verifica THREE global
  if (!window.THREE) {
    alert("No se pudo cargar Three.js");
    return;
  }

  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0f14);

  const camera = new THREE.PerspectiveCamera(45, 2, 1, 50000);
  camera.position.set(2500, -2600, 1200);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.target.set(1500, 0, 430);

  scene.add(new THREE.HemisphereLight(0xffffff, 0x101418, 0.9));
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(3000, -2000, 2000);
  scene.add(dir);

  // Ayudas visuales
  const axes = new THREE.AxesHelper(500);  // X rojo, Y verde, Z azul
  scene.add(axes);
  const grid = new THREE.GridHelper(6000, 60, 0x2a3a4d, 0x1c2734);
  grid.rotation.x = Math.PI/2;
  grid.position.set(1500, 0, 0);
  scene.add(grid);

  // ======= MODELO DEL MUEBLE (3000×620×870 mm, sin tapa) =======
  const W=3000, D=620, H=870, T=18, WL=800, WC=1400, WR=800;
  const matCuerpo = new THREE.MeshStandardMaterial({ color:0xdadada, roughness:0.9 });
  const matDiv    = new THREE.MeshStandardMaterial({ color:0xb3b3b3, roughness:0.9 });
  const matEst    = new THREE.MeshStandardMaterial({ color:0xc8c8c8, roughness:0.9 });
  const matFront  = new THREE.MeshStandardMaterial({ color:0x4d80bd, roughness:0.6 });
  const matCaja   = new THREE.MeshStandardMaterial({ color:0x87cefa, roughness:0.6 });
  const matPuerta = new THREE.MeshStandardMaterial({ color:0x2a8c55, roughness:0.6 });
  const matPAb    = new THREE.MeshStandardMaterial({ color:0x90ee90, roughness:0.6, transparent:true, opacity:0.9 });

  function box(dx,dy,dz,mat,x=0,y=0,z=0){
    const m=new THREE.Mesh(new THREE.BoxGeometry(dx,dy,dz),mat);
    m.position.set(x+dx/2,y+dy/2,z+dz/2);
    scene.add(m);
    return m;
  }

  // Carcasa (sin tapa)
  box(W, T, T,  matCuerpo, 0,   0, 0);   // piso
  box(W, T, H,  matCuerpo, 0, D-T, 0);   // fondo
  box(T, D, H,  matCuerpo, 0,   0, 0);   // lateral izq
  box(T, D, H,  matCuerpo, W-T, 0, 0);   // lateral der
  // Divisiones
  box(T, D, H,  matDiv, WL-T/2, 0, 0);
  box(T, D, H,  matDiv, WL+WC-T/2, 0, 0);
  // Estante central
  box(WC, D, T, matEst, WL, 0, H/2 - T/2);

  // Frentes cajones izq (3 cerrados + 1 abierto)
  const step = H/4, gap=2;
  for(let i=0;i<4;i++){
    const z0=i*step+gap, h=step-2*gap;
    if(i===1){
      box(WL, 200, h, matCaja,  0, -200, z0); // caja extraída
      box(WL, T,   h, matFront, 0, -T,   z0); // frente
    }else{
      box(WL, T,   h, matFront, 0,  0,   z0); // frente cerrado
    }
  }

  // Puertas centro: derecha cerrada; izquierda abierta
  box(WC/2, T, H-4, matPuerta, WL+WC/2, 0, 2); // derecha cerrada

  // Puerta izquierda pivotada (grupo manual simple)
  const pivot = new THREE.Group();
  pivot.position.set(WL, 0, 0);
  scene.add(pivot);
  const puertaIzq = new THREE.Mesh(new THREE.BoxGeometry(WC/2, T, H-4), matPAb);
  puertaIzq.position.set(WC/4, T/2, (H-4)/2);
  pivot.add(puertaIzq);
  pivot.rotation.y = -THREE.Math.degToRad(70);

  // Módulo derecho: cajón sup abierto + puerta inf cerrada
  const zDer = H*0.75+2, hDer = H*0.25-4;
  box(WR, 220, hDer, matCaja,  WL+WC, -220, zDer);
  box(WR, T,   hDer, matFront, WL+WC, -T,   zDer);
  box(WR, T,   H*0.75-4, matPuerta, WL+WC, 0, 2);

  // Cubo test (para verificar render)
  const test = new THREE.Mesh(
    new THREE.BoxGeometry(80,80,80),
    new THREE.MeshStandardMaterial({color:0xff8844})
  );
  test.position.set(-200,-200,80);
  scene.add(test);

  function resize(){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    renderer.setSize(w,h,false);
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
  }

  function loop(){
    resize();
    controls.update();
    renderer.render(scene,camera);
    requestAnimationFrame(loop);
  }
  loop();
})();
</script>
</body>
</html>
