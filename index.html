<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mueble 3D LITE</title>
<style>
  html,body { margin:0; height:100%; background:#0b0f14; }
  #c { display:block; width:100%; height:100%; }
  .hud { position:fixed; left:10px; top:10px; color:#cde; font:14px system-ui; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hud">Arrastrá para rotar · rueda/gesto para zoom</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0f14);

// Cámara
const camera = new THREE.PerspectiveCamera(45, 2, 1, 50000);
camera.position.set(2500, -2600, 1200);

// Controles
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.target.set(1500, 0, 430);

// Luces
scene.add(new THREE.HemisphereLight(0xffffff, 0x101418, 0.9));
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(3000, -2000, 2000);
scene.add(dir);

// Ayudas
scene.add(new THREE.AxesHelper(500)); // X rojo, Y verde, Z azul
const grid = new THREE.GridHelper(6000, 60, 0x2a3a4d, 0x1c2734);
grid.rotation.x = Math.PI/2;
grid.position.set(1500, 0, 0);
scene.add(grid);

// ======= MODELO DEL MUEBLE (3000×620×870 mm, sin tapa) =======
const W=3000, D=620, H=870, T=18, WL=800, WC=1400, WR=800;
const matCuerpo = new THREE.MeshStandardMaterial({ color:0xdadada, roughness:0.9 });
const matDiv    = new THREE.MeshStandardMaterial({ color:0xb3b3b3, roughness:0.9 });
const matEst    = new THREE.MeshStandardMaterial({ color:0xc8c8c8, roughness:0.9 });
const matFront  = new THREE.MeshStandardMaterial({ color:0x4d80bd, roughness:0.6 });
const matCaja   = new THREE.MeshStandardMaterial({ color:0x87cefa, roughness:0.6 });
const matPuerta = new THREE.MeshStandardMaterial({ color:0x2a8c55, roughness:0.6 });
const matPAb    = new THREE.MeshStandardMaterial({ color:0x90ee90, roughness:0.6, transparent:true, opacity:0.9 });

function box(dx,dy,dz,mat,x=0,y=0,z=0){
  const m=new THREE.Mesh(new THREE.BoxGeometry(dx,dy,dz),mat);
  m.position.set(x+dx/2,y+dy/2,z+dz/2);
  return m;
}

const root = new THREE.Group(); scene.add(root);
// piso, fondo, laterales
root.add(box(W, T, T,  matCuerpo, 0,   0, 0));
root.add(box(W, T, H,  matCuerpo, 0, D-T, 0));
root.add(box(T, D, H,  matCuerpo, 0,   0, 0));
root.add(box(T, D, H,  matCuerpo, W-T, 0, 0));
// divisiones
root.add(box(T, D, H,  matDiv, WL-T/2, 0, 0));
root.add(box(T, D, H,  matDiv, WL+WC-T/2, 0, 0));
// estante central
root.add(box(WC, D, T, matEst, WL, 0, H/2 - T/2));

// Frentes cajones izq (3 cerrados + 1 abierto)
const step = H/4, gap=2;
for(let i=0;i<4;i++){
  const z0=i*step+gap, h=step-2*gap;
  if(i===1){
    root.add(box(WL, 200, h, matCaja, 0, -200, z0)); // caja extraída
    root.add(box(WL, T,   h, matFront,0, -T,   z0)); // frente
  }else{
    root.add(box(WL, T,   h, matFront,0, 0,    z0));
  }
}

// Puertas centro: derecha cerrada; izquierda abierta
root.add(box(WC/2, T, H-4, matPuerta, WL+WC/2, 0, 2));
const piv = new THREE.Group(); piv.position.set(WL,0,0); root.add(piv);
const puertaIzq = box(WC/2, T, H-4, matPAb, 0, 0, 2);
puertaIzq.position.set(WC/4, T/2, (H-4)/2);
piv.add(puertaIzq);
piv.rotation.y = -THREE.MathUtils.degToRad(70);

// Módulo derecho: cajón sup abierto + puerta inf cerrada
const zDer = H*0.75+2, hDer = H*0.25-4;
root.add(box(WR, 220, hDer, matCaja,  WL+WC, -220, zDer));
root.add(box(WR, T,   hDer, matFront, WL+WC, -T,   zDer));
root.add(box(WR, T,   H*0.75-4, matPuerta, WL+WC, 0, 2));

// ======= CUBO TEST (para confirmar que se ve algo) =======
const test = new THREE.Mesh(new THREE.BoxGeometry(80,80,80),
                            new THREE.MeshStandardMaterial({color:0xff8844}));
test.position.set(-200, -200, 80);
scene.add(test);

// Render
function resizeRenderer(){
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  const dpr = Math.min(window.devicePixelRatio||1, 2);
  renderer.setSize(w, h, false);
  renderer.setPixelRatio(dpr);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
}
function loop(){
  resizeRenderer();
  controls.update();
  renderer.render(scene,camera);
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
